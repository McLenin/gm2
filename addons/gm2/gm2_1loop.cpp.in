// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "MSSM_gm2_wrapper.hpp"
#include "gm2_1loop.hpp"
#include "linalg.h"
#include "logger.hpp"
#include "wrappers.hpp"
#include <complex.h>

namespace flexiblesusy {
namespace gm2 {

double amuWHnu(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_vu() / model.get_vd();
   double M2 = model.get_MassWB();
   double MUE = model.get_Mu();
   double MSf_112 = model.get_MSv()(2);

   return ( sqr(model.get_g2()) * 2. * oneOver16PiSqr
            * (sqr(model.get_MFe()(2)) * M2 * MUE * tan_beta)
            / sqr(sqr(MSf_112))
            * Fa(sqr(M2 / MSf_112), sqr(MUE / MSf_112)) );
}

double amuWHmuL(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_vu() / model.get_vd();
   double M2 = model.get_MassWB();
   double MUE = model.get_Mu();
   double MSL_2 = sqrt(model.get_ml2()(1, 1));

   return ( - sqr(model.get_g2()) * oneOver16PiSqr
            * (sqr(model.get_MFe()(2)) * M2 * MUE * tan_beta)
            / sqr(sqr(MSL_2))
            * Fb(sqr(M2 / MSL_2), sqr(MUE / MSL_2)) );
}

double amuBHmuL(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_vu() / model.get_vd();
   double M1 = model.get_MassB();
   double MUE = model.get_Mu();
   double MSL_2 = sqrt(model.get_ml2()(1, 1));
   double gY = model.get_g1() * sqrt(3. / 5.);

   return ( sqr(gY) * oneOver16PiSqr
            * (sqr(model.get_MFe()(2)) * M1 * MUE * tan_beta)
            / sqr(sqr(MSL_2))
            * Fb(sqr(M1 / MSL_2), sqr(MUE / MSL_2)) );
}

double amuBHmuR(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_vu() / model.get_vd();
   double M1 = model.get_MassB();
   double MUE = model.get_Mu();
   double MSE_2 = sqrt(model.get_me2()(1, 1));
   double gY = model.get_g1() * sqrt(3. / 5.);

   return ( - sqr(gY) * 2. * oneOver16PiSqr
            * (sqr(model.get_MFe()(2)) * M1 * MUE * tan_beta)
            / sqr(sqr(MSE_2))
            * Fb(sqr(M1 / MSE_2), sqr(MUE / MSE_2)) );
}

double amuBmuLmuR(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_vu() / model.get_vd();
   double M1 = model.get_MassB();
   double MUE = model.get_Mu();
   double MSL_2 = sqrt(model.get_ml2()(1, 1));
   double MSE_2 = sqrt(model.get_me2()(1, 1));
   double gY = model.get_g1() * sqrt(3. / 5.);

   return ( sqr(gY) * 2. * oneOver16PiSqr
            * (sqr(model.get_MFe()(2)) * MUE * tan_beta)
            / (M1 * sqr(M1))
            * Fb(sqr(MSL_2 / M1), sqr(MSE_2 / M1)) );
}

double amu1Lapprox(const MSSM_gm2_wrapper& model) {

   return ( amuWHnu(model) + amuWHmuL(model) + amuBHmuL(model)
            + amuBHmuR(model) + amuBmuLmuR(model) );
}

ComplexMatrix n_L(const MSSM_gm2_wrapper& model) {
   ComplexMatrix n__L(4, 2);
   double g1 = model.get_g1();
   double g2 = model.get_g2();
   double ymu = model.get_Ye()(1, 1);
   ComplexMatrix ZN(model.get_ZN());
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   for(int i=1; i <=4; ++i) {
      for(int m=1; m <=2; ++m) {
         n__L(i, m) = ( (1. / sqrt(2.) * ( g1 * model.get_ZN()(i, 1)
                                         + g2 * ZN(i, 2) ) * Conj(u_smu(m, 1)) )
                      - ymu * ZN(i, 3) * Conj(u_smu(m, 2)) );
      }
   }

   return n__L;
}


ComplexMatrix n_R(const MSSM_gm2_wrapper& model) {
   ComplexMatrix n__R(4, 2);
   double g1 = model.get_g1();
   double ymu = model.get_Ye()(1, 1);
   ComplexMatrix ZN(model.get_ZN());
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   for(int i=1; i <=4; ++i) {
      for(int m=1; m <=2; ++m) {
         n__R(i, m) = ( sqrt(2.) * g1 * ZN(i, 1) * u_smu(m, 2) 
                       + ymu * ZN(i, 3) * u_smu(m, 1) );
      }
   }

   return n__R;
}

ComplexVector c_L(const MSSM_gm2_wrapper& model) {
   ComplexVector c__L(2);
   double g2 = model.get_g2();
   for(int k=1; k<=2; ++k) {
      c__L(k) = - g2 * model.get_UP()(k, 1);
   }
   return c__L;
}

ComplexVector c_R(const MSSM_gm2_wrapper& model) {
   ComplexVector c__R(2);
   double ymu = model.get_Ye()(1, 1);
   for(int k=1; k<=2; ++k) {
      c__R(k) = ymu * model.get_UM()(k, 2);
   }

   return c__R;
}

DoubleVector AAC(const MSSM_gm2_wrapper& model) {
   DoubleVector result(2);
   ComplexVector c__L = c_L(model);
   ComplexVector c__R = c_R(model);
   for(int k=1; k<=2; ++k) {
      result(k) = norm(c__L(k)) + norm(c__R(k));
   }

   return result;
}

DoubleMatrix AAN(const MSSM_gm2_wrapper& model) {
   DoubleMatrix result(4, 2);
   ComplexMatrix n__L = n_L(model);
   ComplexMatrix n__R = n_R(model);
   for(int i=1; i<=4; ++i) {
      for(int m=1; m<=2; ++m) {
         result(i, m) = norm(n__L(i, m)) + norm(n__R(i, m));
      }
   }

   return result;
}

DoubleVector BBC(const MSSM_gm2_wrapper& model) {
   DoubleVector result(2);
   ComplexVector c__L = c_L(model);
   ComplexVector c__R = c_R(model);
   for(int k=1; k<=2; ++k) {
      result(k) = real(c__L(k) * c__R(k)) / model.get_MFe()(2);
   }

   return result;
}

DoubleMatrix BBN(const MSSM_gm2_wrapper& model) {
   DoubleMatrix result(4, 2);
   ComplexMatrix n__L = n_L(model);
   ComplexMatrix n__R = n_R(model);
   for(int i=1; i<=4; ++i) {
      for(int m=1; m<=2; ++m) {
         result(i, m) = real(n__L(i, m) * n__R(i, m)) / model.get_MFe()(2);
      }
   }

   return result;
}

DoubleMatrix x_im(const MSSM_gm2_wrapper& model) {
   DoubleMatrix x__im(4, 2);
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   DoubleVector MChi(model.get_MChi());
   for(int i=1; i <=4; ++i) {
      for(int m=1; m <=2; ++m) {
         x__im(i, m) = sqr(MChi(i) / m_smu(m));
      }
   }

   return x__im;
}

DoubleVector x_k(const MSSM_gm2_wrapper& model) {
   DoubleVector x__k(2);
   for(int k=1; k<=2; ++k) {
      x__k(k) = sqr(model.get_MCha()(k) / model.get_MSv()(2));
   }

   return x__k;
}

double amuChi0(const MSSM_gm2_wrapper& model) {
   double alpha = 0.;
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   ComplexMatrix n__L = n_L(model);
   ComplexMatrix n__R = n_R(model);
   DoubleMatrix x__im = x_im(model);
   DoubleVector MChi(model.get_MChi());
   for(int i=1; i<=4; ++i) {
      for(int m=1; m<=2; ++m) {
         alpha += (- model.get_MFe()(2) * (norm(n__L(i, m)) + norm(n__R(i, m)))
                    * F1N(x__im(i, m)) / (12. * sqr(m_smu(m)))
                   + MChi(i) * real(n__L(i, m) * n__R(i, m))
                    * F2N(x__im(i, m)) / (3. * sqr(m_smu(m))) );
      }
   }

   return alpha * model.get_MFe()(2) * oneOver16PiSqr;
}

double amuChipm(const MSSM_gm2_wrapper& model) {
   double alpha = 0.;
   ComplexVector c__L = c_L(model);
   ComplexVector c__R = c_R(model);
   DoubleVector x__k = x_k(model);
   DoubleVector MSv = model.get_MSv();
   for(int k=1; k<=2; ++k) {
      alpha += (  model.get_MFe()(2) * (norm(c__L(k)) + norm(c__R(k)))
                 * F1C(x__k(k)) / (12. * sqr(MSv(2)))
                + 2. * model.get_MCha()(k) * real(c__L(k) * c__R(k))
                 * F2C(x__k(k)) / (3. * sqr(MSv(2))) );
   }

   return alpha * model.get_MFe()(2) * oneOver16PiSqr;
}

double calculate_gm2_1loop(const MSSM_gm2_wrapper& model) {

   return amuChi0(model) + amuChipm(model); //@gm2_1l@;
}

} // namespace gm2
} // namespace flexiblesusy
