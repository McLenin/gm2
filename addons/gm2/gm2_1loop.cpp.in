// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "MSSM_gm2_wrapper.hpp"
#include "gm2_1loop.hpp"
#include "linalg.h"
#include "logger.hpp"
#include "wrappers.hpp"
#include <complex.h>

namespace flexiblesusy {
namespace gm2 {

// approximations

double amuWHnu(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_TB();
   double M2 = model.get_MassWB();
   double MUE = model.get_Mu();
   double MSv_2 = model.get_MSv()(2);

   return ( sqr(model.get_g2()) * 2. * oneOver16PiSqr
            * (sqr(model.get_MM()) * M2 * MUE * tan_beta)
            / sqr(sqr(MSv_2))
            * Fa(sqr(M2 / MSv_2), sqr(MUE / MSv_2)) );
}

double amuWHmuL(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_TB();
   double M2 = model.get_MassWB();
   double MUE = model.get_Mu();
   double MSL_2 = sqrt(model.get_ml2()(1, 1));

   return ( - sqr(model.get_g2()) * oneOver16PiSqr
            * (sqr(model.get_MM()) * M2 * MUE * tan_beta)
            / sqr(sqr(MSL_2))
            * Fb(sqr(M2 / MSL_2), sqr(MUE / MSL_2)) );
}

double amuBHmuL(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_TB();
   double M1 = model.get_MassB();
   double MUE = model.get_Mu();
   double MSL_2 = sqrt(model.get_ml2()(1, 1));
   double gY = model.get_gY();

   return ( sqr(gY) * oneOver16PiSqr
            * (sqr(model.get_MM()) * M1 * MUE * tan_beta)
            / sqr(sqr(MSL_2))
            * Fb(sqr(M1 / MSL_2), sqr(MUE / MSL_2)) );
}

double amuBHmuR(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_TB();
   double M1 = model.get_MassB();
   double MUE = model.get_Mu();
   double MSE_2 = sqrt(model.get_me2()(1, 1));
   double gY = model.get_gY();

   return ( - sqr(gY) * 2. * oneOver16PiSqr
            * (sqr(model.get_MM()) * M1 * MUE * tan_beta)
            / sqr(sqr(MSE_2))
            * Fb(sqr(M1 / MSE_2), sqr(MUE / MSE_2)) );
}

double amuBmuLmuR(const MSSM_gm2_wrapper& model) {
   double tan_beta = model.get_TB();
   double M1 = model.get_MassB();
   double MUE = model.get_Mu();
   double MSL_2 = sqrt(model.get_ml2()(1, 1));
   double MSE_2 = sqrt(model.get_me2()(1, 1));
   double gY = model.get_gY();

   return ( sqr(gY) * 2. * oneOver16PiSqr
            * (sqr(model.get_MM()) * MUE * tan_beta)
            / (M1 * sqr(M1))
            * Fb(sqr(MSL_2 / M1), sqr(MSE_2 / M1)) );
}

double amu1Lapprox(const MSSM_gm2_wrapper& model) {

   return ( amuWHnu(model) + amuWHmuL(model) + amuBHmuL(model)
            + amuBHmuR(model) + amuBmuLmuR(model) );
}

// complete computation

ComplexMatrix n_L(const MSSM_gm2_wrapper& model) {
   ComplexMatrix result(4, 2);
   double gY =  model.get_gY();
   double g2 = model.get_g2();
   double ymu = model.get_Ye()(1, 1);
   ComplexMatrix ZN(model.get_ZN());
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   for(int i=1; i <=4; ++i) {
      for(int m=1; m <=2; ++m) {
         result(i, m) = ( (1. / sqrt(2.) * ( gY * model.get_ZN()(i, 1)
                                         + g2 * ZN(i, 2) ) * Conj(u_smu(m, 1)) )
                      - ymu * ZN(i, 3) * Conj(u_smu(m, 2)) );
      }
   }

   return result;
}

ComplexMatrix n_R(const MSSM_gm2_wrapper& model) {
   ComplexMatrix result(4, 2);
   double gY = model.get_gY();
   double ymu = model.get_Ye()(1, 1);
   ComplexMatrix ZN(model.get_ZN());
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   for(int i=1; i <=4; ++i) {
      for(int m=1; m <=2; ++m) {
         result(i, m) = ( sqrt(2.) * gY * ZN(i, 1) * u_smu(m, 2) 
                       + ymu * ZN(i, 3) * u_smu(m, 1) );
      }
   }

   return result;
}

ComplexVector c_L(const MSSM_gm2_wrapper& model) {
   ComplexVector result(2);
   double g2 = model.get_g2();
   ComplexMatrix UP(model.get_UP());
   for(int k=1; k<=2; ++k) {
      result(k) = - g2 * UP(k, 1);
   }
   return result;
}

ComplexVector c_R(const MSSM_gm2_wrapper& model) {
   ComplexVector result(2);
   double ymu = model.get_Ye()(1, 1);
   ComplexMatrix UM(model.get_UM());
   for(int k=1; k<=2; ++k) {
      result(k) = ymu * UM(k, 2);
   }

   return result;
}

DoubleVector AAC(const MSSM_gm2_wrapper& model) {
   DoubleVector result(2);
   ComplexVector c__L = c_L(model);
   ComplexVector c__R = c_R(model);
   for(int k=1; k<=2; ++k) {
      result(k) = norm(c__L(k)) + norm(c__R(k));
   }

   return result;
}

DoubleMatrix AAN(const MSSM_gm2_wrapper& model) {
   DoubleMatrix result(4, 2);
   ComplexMatrix n__L = n_L(model);
   ComplexMatrix n__R = n_R(model);
   for(int i=1; i<=4; ++i) {
      for(int m=1; m<=2; ++m) {
         result(i, m) = norm(n__L(i, m)) + norm(n__R(i, m));
      }
   }

   return result;
}

DoubleVector BBC(const MSSM_gm2_wrapper& model) {
   DoubleVector result(2);
   ComplexVector c__L = c_L(model);
   ComplexVector c__R = c_R(model);
   for(int k=1; k<=2; ++k) {
      result(k) = real(c__L(k) * c__R(k)) / model.get_MM();
   }

   return result;
}

DoubleMatrix BBN(const MSSM_gm2_wrapper& model) {
   DoubleMatrix result(4, 2);
   ComplexMatrix n__L = n_L(model);
   ComplexMatrix n__R = n_R(model);
   for(int i=1; i<=4; ++i) {
      for(int m=1; m<=2; ++m) {
         result(i, m) = real(n__L(i, m) * n__R(i, m)) / model.get_MM();
      }
   }

   return result;
}

DoubleMatrix x_im(const MSSM_gm2_wrapper& model) {
   DoubleMatrix result(4, 2);
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   DoubleVector MChi(model.get_MChi());
   for(int i=1; i <=4; ++i) {
      for(int m=1; m <=2; ++m) {
         result(i, m) = sqr(MChi(i) / m_smu(m));
      }
   }

   return result;
}

DoubleVector x_k(const MSSM_gm2_wrapper& model) {
   DoubleVector result(2);
   for(int k=1; k<=2; ++k) {
      result(k) = sqr(model.get_MCha()(k) / model.get_MSv()(2));
   }

   return result;
}

double amuChi0(const MSSM_gm2_wrapper& model) {
   double result = 0.;
   DoubleVector m_smu(model.get_MSmu());
   DoubleMatrix u_smu(model.get_USmu());
   DoubleMatrix AAN_(AAN(model));
   DoubleMatrix BBN_(BBN(model));
   DoubleMatrix x__im(x_im(model));
   DoubleVector MChi(model.get_MChi());
   for(int i=1; i<=4; ++i) {
      for(int m=1; m<=2; ++m) {
         result += ( - AAN_(i, m) * F1N(x__im(i, m)) / (12. * sqr(m_smu(m)))
                     + MChi(i) * BBN_(i, m) * F2N(x__im(i, m))
                      / (3. * sqr(m_smu(m))) );
      }
   }

   return result * sqr(model.get_MM()) * oneOver16PiSqr;
}

double amuChipm(const MSSM_gm2_wrapper& model) {
   double result = 0.;
   DoubleVector x__k(x_k(model));
   DoubleVector MSv(model.get_MSv());
   DoubleVector AAC_(AAC(model));
   DoubleVector BBC_(BBC(model));
   DoubleVector MCha(model.get_MCha());
   for(int k=1; k<=2; ++k) {
      result += ( AAC_(k) * F1C(x__k(k)) / (12. * sqr(MSv(2)))
                 + 2. * MCha(k) * BBC_(k) * F2C(x__k(k))
                  / (3. * sqr(MSv(2))) );
   }

   return result * sqr(model.get_MM()) * oneOver16PiSqr;
}

double calculate_gm2_1loop(const MSSM_gm2_wrapper& model) {

   return amuChi0(model) + amuChipm(model); //@gm2_1l@;
}

} // namespace gm2
} // namespace flexiblesusy
