// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "gm2_1loop.hpp"
#include "gm2_2loop.hpp"
#include "linalg.h"
#include "logger.hpp"
#include "wrappers.hpp"
#include "MSSM_gm2_wrapper.hpp"
#include <complex.h>

namespace flexiblesusy {
namespace gm2 {

double tan_beta_cor(const MSSM_gm2_wrapper& model) {
   double delta_mu;
   double mu = model.get_Mu();
   double TB = model.get_vu() / model.get_vd();
   double g2 = model.get_g2();
   double g1 = model.get_g1();
   double M1 = model.get_MassB();
   double M2 = model.get_MassWB();
   double MW = 78.4507;
   double MZ = 90.0894;
   double SW = sqrt(1. - sqr(MW / MZ));
   double m1 = ( sqrt(0.5 * (sqr(M2) + sqr(mu) + 2. * sqr(MW)
               - sqrt(sqr(sqr(M2) + sqr(mu) + 2. * sqr(MW)) - sqr(2. * M2 * mu)))) );
   double m2 = ( sqrt(0.5 * (sqr(M2) + sqr(mu) + 2. * sqr(MW)
               + sqrt(sqr(sqr(M2) + sqr(mu) + 2. * sqr(MW)) - sqr(2. * M2 * mu)))) );
   double m_sneu_mu = sqrt(model.get_ml2()(1, 1) - 0.5 * sqr(MZ));
   double m_smu_L = sqrt(model.get_ml2()(1, 1) - sqr(MZ) * (sqr(SW) - 0.5));
   double m_smu_R = sqrt(model.get_me2()(1, 1) + sqr(MZ * SW));

   delta_mu = ( - mu * TB * oneOver16PiSqr
            * (sqr(g2) * M2 * (Iabc(m1, m2, m_sneu_mu) + 0.5 * Iabc(m1, m2, m_smu_L))
            + sqr(g1) * M1 * (Iabc(mu, M1, m_smu_R) - 0.5 * Iabc(mu, M1, m_smu_L)
                              - Iabc(M1, m_smu_L, m_smu_R))) );

   return 1. / (1. + delta_mu);
}

double Deltag1(const MSSM_gm2_wrapper& model) {
   double gY = model.get_g1() * sqrt(3. / 5.);
   double LogScale = fabs(model.get_MassB());
   Eigen::Matrix<double,3,3> mu2(model.get_mu2());
   Eigen::Matrix<double,3,3> md2(model.get_md2());
   Eigen::Matrix<double,3,3> mq2(model.get_mq2());
   Eigen::Matrix<double,3,3> me2(model.get_me2());
   Eigen::Matrix<double,3,3> ml2(model.get_ml2());

   return ( sqr(gY) * oneOver16PiSqr * 4. / 3.
            * (8. / 3. * log(mu2(0, 0) / LogScale) + 4. / 3. * log(mu2(2, 2) / LogScale)
             + 2. / 3. * log(md2(0, 0) / LogScale) + 1. / 3. * log(md2(2, 2) / LogScale)
             + 1. / 3. * log(mq2(0, 0) / LogScale) + 1. / 6. * log(mq2(2, 2) / LogScale)
             + log(me2(2, 2) / LogScale) + 1. / 2. * log(ml2(2, 2) / LogScale)) );
}

double DeltaYukHiggsino(const MSSM_gm2_wrapper& model) {
   double LogScale = fabs(model.get_MassB());
   double ytau = model.get_Ye()(2, 2);
   double ytop = model.get_Yu()(2, 2);
   double ybot = model.get_Yd()(2, 2);
   Eigen::Matrix<double,3,3> mu2(model.get_mu2());
   Eigen::Matrix<double,3,3> md2(model.get_md2());
   Eigen::Matrix<double,3,3> mq2(model.get_mq2());
   Eigen::Matrix<double,3,3> me2(model.get_me2());
   Eigen::Matrix<double,3,3> ml2(model.get_ml2());

   return ( oneOver16PiSqr * 0.5
            * (3. * sqr(ytop) * log(mu2(2, 2) / LogScale)
             + 3. * sqr(ybot) * log(md2(2, 2) / LogScale)
             + 3. * (sqr(ytop) + sqr(ybot)) * log(mq2(2, 2) / LogScale)) );
}

} // namespace gm2
} // namespace flexiblesusy
