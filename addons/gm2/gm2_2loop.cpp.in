// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "gm2_1loop.hpp"
#include "gm2_2loop.hpp"
#include "linalg.h"
#include "logger.hpp"
#include "wrappers.hpp"
#include <complex.h>

namespace flexiblesusy {
namespace gm2 {

//tanbeta2 corrections

double tan_beta_cor(const MSSM_gm2_wrapper& model) {
   double delta_mu;
   double mu = model.get_Mu();
   double TB = model.get_TB();
   double g2 = model.get_g2();
   double g1 = model.get_g1();
   double M1 = model.get_MassB();
   double M2 = model.get_MassWB();
   double MW = model.get_MW();
   double MZ = model.get_MZ();
   double SW = sqrt(1. - sqr(MW / MZ));
   double m1 = ( sqrt(0.5 * (sqr(M2) + sqr(mu) + 2. * sqr(MW)
               - sqrt(sqr(sqr(M2) + sqr(mu) + 2. * sqr(MW)) - sqr(2. * M2 * mu)))) );
   double m2 = ( sqrt(0.5 * (sqr(M2) + sqr(mu) + 2. * sqr(MW)
               + sqrt(sqr(sqr(M2) + sqr(mu) + 2. * sqr(MW)) - sqr(2. * M2 * mu)))) );
   double m_sneu_mu = sqrt(model.get_ml2()(1, 1) - 0.5 * sqr(MZ));
   double m_smu_L = sqrt(model.get_ml2()(1, 1) - sqr(MZ) * (sqr(SW) - 0.5));
   double m_smu_R = sqrt(model.get_me2()(1, 1) + sqr(MZ * SW));

   delta_mu = ( - mu * TB * oneOver16PiSqr
            * (sqr(g2) * M2 * (Iabc(m1, m2, m_sneu_mu) + 0.5 * Iabc(m1, m2, m_smu_L))
            + sqr(g1) * M1 * (Iabc(mu, M1, m_smu_R) - 0.5 * Iabc(mu, M1, m_smu_L)
                              - Iabc(M1, m_smu_L, m_smu_R))) );

   return 1. / (1. + delta_mu);
}

// fermion/sfermion corrections, log-approximations

double LogNorm(const MSSM_gm2_wrapper& model) {
   // function to find minimum special masses to normalize logarithms

   return fmin(fabs(model.get_MassB()),
           fmin(fabs(model.get_MassWB()),
            fmin(fabs(model.get_Mu()),
             fmin(sqrt(model.get_me2()(1, 1)), sqrt(model.get_ml2()(1, 1))))));
}

double Deltag1(const MSSM_gm2_wrapper& model) {
   double gY = model.get_gY();
   Eigen::Matrix<double,3,3> mu2(model.get_mu2());
   Eigen::Matrix<double,3,3> md2(model.get_md2());
   Eigen::Matrix<double,3,3> mq2(model.get_mq2());
   Eigen::Matrix<double,3,3> me2(model.get_me2());
   Eigen::Matrix<double,3,3> ml2(model.get_ml2());
   double LogScale = LogNorm(model);

   return ( sqr(gY) * oneOver16PiSqr * 4. / 3.
            * (8. / 3. * log(sqrt(mu2(0, 0)) / LogScale) + 4. / 3. * log(sqrt(mu2(2, 2)) / LogScale)
             + 2. / 3. * log(sqrt(md2(0, 0)) / LogScale) + 1. / 3. * log(sqrt(md2(2, 2)) / LogScale)
             + 1. / 3. * log(sqrt(mq2(0, 0)) / LogScale) + 1. / 6. * log(sqrt(mq2(2, 2)) / LogScale)
             + log(sqrt(me2(2, 2)) / LogScale) + 0.5 * log(sqrt(ml2(2, 2)) / LogScale)) );
}

double DeltaYukHiggsino(const MSSM_gm2_wrapper& model) {
   double ytau = model.get_Ye()(2, 2);
   double ytop = model.get_Yu()(2, 2);
   double ybot = model.get_Yd()(2, 2);
   Eigen::Matrix<double,3,3> mu2(model.get_mu2());
   Eigen::Matrix<double,3,3> md2(model.get_md2());
   Eigen::Matrix<double,3,3> mq2(model.get_mq2());
   Eigen::Matrix<double,3,3> me2(model.get_me2());
   Eigen::Matrix<double,3,3> ml2(model.get_ml2());
   double LogScale = LogNorm(model);

   return ( oneOver16PiSqr * 0.5
            * (3. * sqr(ytop) * log(sqrt(mu2(2, 2)) / LogScale)
             + 3. * sqr(ybot) * log(sqrt(md2(2, 2)) / LogScale)
             + 3. * (sqr(ytop) + sqr(ybot)) * log(sqrt(mq2(2, 2)) / LogScale)
             + sqr(ytau) * (log(sqrt(me2(2, 2)) / LogScale) + log(sqrt(ml2(2, 2)) / LogScale))) );
}

double DeltaYukBinoHiggsino(const MSSM_gm2_wrapper& model) {
   double ytop = model.get_Yu()(2, 2);
   Eigen::Matrix<double,3,3> mu2(model.get_mu2());
   Eigen::Matrix<double,3,3> mq2(model.get_mq2());
   double LogScale = LogNorm(model);

   return ( oneOver16PiSqr * sqr(ytop) * ( - 8. * log(sqrt(mu2(2, 2)) / LogScale)
                            + 2. * log(sqrt(mq2(2, 2)) / LogScale)) );
}

double Deltag2(const MSSM_gm2_wrapper& model) {
   double g2 = model.get_g2();
   Eigen::Matrix<double,3,3> mq2(model.get_mq2());
   Eigen::Matrix<double,3,3> ml2(model.get_ml2());
   double LogScale = LogNorm(model);

   return ( sqr(g2) * oneOver16PiSqr * 4. / 3.
            * (3. * log(sqrt(mq2(0, 0)) / LogScale) + 1.5 * log(sqrt(mq2(2, 2)) / LogScale)
             + 0.5 * log(sqrt(ml2(2, 2)) / LogScale)) );
}

double DeltaYukWinoHiggsino(const MSSM_gm2_wrapper& model) {
   double ytop = model.get_Yu()(2, 2);
   Eigen::Matrix<double,3,3> mq2(model.get_mq2());
   double LogScale = LogNorm(model);

   return oneOver16PiSqr * - 6. * sqr(ytop) * log(sqrt(mq2(2, 2)) / LogScale);
}

double DeltaTanBeta(const MSSM_gm2_wrapper& model) {;
   double ytau = model.get_Ye()(2, 2);
   double ytop = model.get_Yu()(2, 2);
   double ybot = model.get_Yd()(2, 2);
   double LogScale = LogNorm(model);
   double MUDIM = 454.7;

   return ( oneOver16PiSqr * (sqr(ytau) - 3. * sqr(ytop) + 3. * sqr(ybot))
             * log(MUDIM / LogScale) );
}

double amuWHnu2L(const MSSM_gm2_wrapper& model) {
   double test1 = .75;

   return ( amuWHnu(model)
            * (.02 * test1 + Deltag2(model) + DeltaYukHiggsino(model)
              + DeltaYukWinoHiggsino(model) + DeltaTanBeta(model)) );
}

double amuWHmuL2L(const MSSM_gm2_wrapper& model) {
   double test2 = .75;

   return ( amuWHmuL(model)
            * (.02 * test2 + Deltag2(model) + DeltaYukHiggsino(model)
             + DeltaYukWinoHiggsino(model) + DeltaTanBeta(model))  );
}

double amuBHmuL2L(const MSSM_gm2_wrapper& model) {
   double test3 = .75;

   return ( amuBHmuL(model)
            * (.02 * test3 + Deltag1(model) + DeltaYukHiggsino(model)
              + DeltaYukBinoHiggsino(model) + DeltaTanBeta(model))  );
}

double amuBHmuR2L(const MSSM_gm2_wrapper& model) {
   double test4 = 2.;

   return ( amuBHmuR(model)
            * (.02 * test4 + Deltag1(model) + DeltaYukHiggsino(model)
              + DeltaYukBinoHiggsino(model) + DeltaTanBeta(model))  );
}

double amuBmuLmuR2L(const MSSM_gm2_wrapper& model) {
   double test5 = 1.5;

   return ( amuBmuLmuR(model)
            * (.02 * test5 + Deltag1(model) + DeltaTanBeta(model)) );
}

double amu2LFSfapprox(const MSSM_gm2_wrapper& model) {

   return ( amuWHnu2L(model) + amuWHmuL2L(model) + amuBHmuL2L(model)
           + amuBHmuR2L(model) + amuBmuLmuR2L(model) );
}

// photonic corrections, all

double amuChipmPhotonic(const MSSM_gm2_wrapper& model) {
   double result = 0.;
   double MM = model.get_MM();
   double alpha = sqr(model.get_EL()) / (4. * Pi);
   DoubleVector AAC_(AAC(model));
   DoubleVector BBC_(BBC(model));
   DoubleVector MCha(model.get_MCha());
   DoubleVector MSv(model.get_MSv());
   DoubleVector x__k(x_k(model));
   double mu_DREG = model.get_Mu();

   for(int k=1; k<=2; k++) {
      result += ( (AAC_(k) * F1C(x__k(k)) / 12. + 2. * MCha(k) / 3. * BBC_(k) * F2C(x__k(k)))
                   * 16. * log(MM / MSv(2))
                  - (47. * AAC_(k) * F3C(x__k(k)) / 72.
                     + 122. * MCha(k) / 9. * BBC_(k) * F4C(x__k(k)))
                  - (0.5 * AAC_(k) * F1C(x__k(k)) + 2. * MCha(k) * BBC_(k) * F2C(x__k(k)))
                   * log(sqr(MSv(2) / mu_DREG)) );
   }

   return  oneOver16PiSqr * sqr(MM / MSv(2)) * alpha * 0.25 / Pi * result;
}

double amuChi0Photonic(const MSSM_gm2_wrapper& model) {
   double result = 0.;
   double MM = model.get_MM();
   double alpha = sqr(model.get_EL()) / (4. * Pi);
   DoubleMatrix AAN_(AAN(model));
   DoubleMatrix BBN_(BBN(model));
   DoubleVector MNeu(model.get_MChi());
   DoubleVector MSmu(model.get_MSmu());
   DoubleMatrix x__im(x_im(model));
   double mu_DREG = model.get_Mu();        // ???

   for(int i=1; i<=4; ++i) {
      for(int m=1; m<=2; ++m) {
         result +=  1. / sqr(MSmu(m))
                    * ((- 1. / 12. * AAN_(i, m) * F1N(x__im(i, m))
                       + MNeu(i) / 3. * BBN_(i, m) * F2N(x__im(i, m)))
                      * 16. * log(MM / MSmu(m))
                     - (- 35. / 72. * AAN_(i, m) * F3N(x__im(i, m))
                       + 16. * MNeu(i) / 9. * BBN_(i, m) * F4N(x__im(i, m)))
                     + (0.25 * AAN_(i, m) * F1N(x__im(i, m)))
                      * log(sqr(MSmu(m) / mu_DREG)) );
      }
   }

   return oneOver16PiSqr * alpha * sqr(MM) * 0.25 / Pi;
}

// some approximations
/*

double tan_alpha(const MSSM_gm2_wrapper& model) {
   double TB = model.get_TB();
   double tan2beta = 2. * TB / sqr(1. - TB);
   double tan2alpha = tan2beta * () / ();

   return 0;
}

ComplexMatrix lambda_muChi(const MSSM_gm2_wrapper& model) {
   ComplexMatrix result(3, 3);
   DoubleMatrix MCha(model.get_MCha());

   for(int k=1; k<=2; ++k) {
      result(k, 1) = ( Sqrt(2.) * MW / MCha(k)
                      * () )
   }
   result(3, 1) = -SA / CB;
   result(3, 2) = CA / CB;
   result(3, 3) = TB;
   return result;
}

double amua2LSferm(const MSSM_gm2_wrapper& model) {
   double result = 0.;

   for(int k=1; k<=2; ++k) {
      result += 0;
   }

   return result * 0.5 * oneOver16PiSqr * sqr(alpha * MM / (MW * SW));
}

double amua2LChi(const MSSM_gm2_wrapper& model) {

   for(int k=1; k<=2; ++k) {
      result += real(lambda_mu() * lambda());
   }

   return result * 0.5 * oneOver16PiSqr * sqr(alpha * MM / (MW * SW));
}
*/
} // namespace gm2
} // namespace flexiblesusy
