// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_two_scale_model.hpp"
#include "@ModelName@_two_scale_susy_scale_constraint.hpp"
#include "@ModelName@_two_scale_low_scale_constraint.hpp"
#include "@ModelName@_two_scale_convergence_tester.hpp"
#include "@ModelName@_two_scale_initial_guesser.hpp"
#include "@ModelName@_utilities.hpp"
#include "@ModelName@_slha_io.hpp"

#include "two_scale_running_precision.hpp"
#include "two_scale_solver.hpp"
#include "coupling_monitor.hpp"
#include "error.hpp"
#include "ew_input.hpp"
#include "program_options.hpp"
#include "lowe.h"
#include "command_line_options.hpp"

#include <iostream>
#include <vector>

namespace flexiblesusy {

template <class T>
class @ModelName@_runner {
public:
   @ModelName@_runner()
      : solver(), model()
      , susy_scale_constraint()
      , low_scale_constraint()
      , susy_scale(0.), low_scale(0.)
      , parameter_output_scale(0.)
      , precision_goal(1.0e-5)
      , max_iterations(0)
      , calculate_sm_masses(false) {}
   ~@ModelName@_runner() {}

   double get_susy_scale() const { return susy_scale; }
   double get_low_scale()  const { return low_scale;  }
   const @ModelName@<T>& get_model() const { return model; }
   const Problems<@ModelName@_info::NUMBER_OF_PARTICLES>& get_problems() const {
      return model.get_problems();
   }
   void set_parameter_output_scale(double s) { parameter_output_scale = s; }
   void set_precision_goal(double precision_goal_) { precision_goal = precision_goal_; }
   void set_pole_mass_loop_order(unsigned l) { model.set_pole_mass_loop_order(l); }
   void set_ewsb_loop_order(unsigned l) { model.set_ewsb_loop_order(l); }
   void set_max_iterations(unsigned n) { max_iterations = n; }
   void set_calculate_sm_masses(bool flag) { calculate_sm_masses = flag; }

   void run(const QedQcd& oneset, const @ModelName@_input_parameters& input);
   void write_running_couplings(const std::string& filename = "@ModelName@_rge_running.dat") const;
   void write_spectrum(const std::string& filename = "@ModelName@_spectrum.dat") const;

private:
   RGFlow<T> solver;
   @ModelName@<T> model;
   @ModelName@_susy_scale_constraint<T> susy_scale_constraint;
   @ModelName@_low_scale_constraint<T>  low_scale_constraint;
   double susy_scale, low_scale;
   double parameter_output_scale; ///< output scale for running parameters
   double precision_goal; ///< precision goal
   unsigned max_iterations; ///< maximum number of iterations
   bool calculate_sm_masses; ///< calculate SM pole masses
};

/**
 * @brief Run's the RG solver with the given input parameters
 *
 * This function sets up the RG solver using a susy-scale
 * and low-scale constraint.  Afterwards the solver is run until
 * convergence is reached or an error occours.  Finally the particle
 * spectrum (pole masses) is calculated.
 *
 * @param oneset Standard Model input parameters
 * @param input model input parameters
 */
template <class T>
void @ModelName@_runner<T>::run(const QedQcd& oneset,
                                const @ModelName@_input_parameters& input)
{
   susy_scale_constraint.reset();
   low_scale_constraint .reset();
   susy_scale_constraint.set_input_parameters(input);
   low_scale_constraint .set_input_parameters(input);

   std::vector<Constraint<T>*> upward_constraints;
   upward_constraints.push_back(&low_scale_constraint);
   upward_constraints.push_back(&susy_scale_constraint);

   std::vector<Constraint<T>*> downward_constraints;
   downward_constraints.push_back(&susy_scale_constraint);
   downward_constraints.push_back(&low_scale_constraint);

   model.set_input(input);
   model.do_calculate_sm_pole_masses(calculate_sm_masses);

   @ModelName@_convergence_tester<T> convergence_tester(&model, precision_goal);
   if (max_iterations > 0)
      convergence_tester.set_max_iterations(max_iterations);

   @ModelName@_initial_guesser<T> initial_guesser(&model, input, oneset,
                                                  low_scale_constraint,
                                                  susy_scale_constraint);
   Two_scale_increasing_precision precision(10.0, precision_goal);

   solver.reset();
   solver.set_convergence_tester(&convergence_tester);
   solver.set_running_precision(&precision);
   solver.set_initial_guesser(&initial_guesser);
   solver.add_model(&model, upward_constraints, downward_constraints);

   susy_scale = low_scale = 0.;

   try {
      solver.solve();
      susy_scale = susy_scale_constraint.get_scale();
      low_scale  = low_scale_constraint.get_scale();

      if (model.run_to(susy_scale))
         throw NonPerturbativeRunningError(susy_scale);

      model.calculate_spectrum();

      // run to output scale (if scale > 0)
      if (std::fabs(parameter_output_scale)
          > std::numeric_limits<double>::epsilon()) {
         if (model.run_to(parameter_output_scale))
            throw NonPerturbativeRunningError(parameter_output_scale);
      }
   } catch (const NoConvergenceError& error) {
      model.get_problems().flag_no_convergence();
      ERROR(error.what());
   } catch (const NonPerturbativeRunningError& error) {
      model.get_problems().flag_no_perturbative();
      ERROR(error.what());
   } catch (const Error& error) {
      model.get_problems().flag_thrown();
      ERROR(error.what());
   } catch (const std::string& str) {
      model.get_problems().flag_thrown();
      ERROR(str);
   } catch (const char* str) {
      model.get_problems().flag_thrown();
      ERROR(str);
   }
}

/**
 * Create a text file which contains the values of all model
 * parameters at all scales between the low-scale and the susy-scale.
 *
 * @param filename name of output file
 */
template <class T>
void @ModelName@_runner<T>::write_running_couplings(const std::string& filename) const
{
   @ModelName@<T> tmp_model(model);
   const unsigned error = tmp_model.run_to(low_scale);
   if (error) {
      ERROR("@ModelName@_runner::write_running_couplings: run to scale "
            << low_scale << " failed");
      return;
   }

   @ModelName@_parameter_getter parameter_getter;
   Coupling_monitor<@ModelName@<T>, @ModelName@_parameter_getter>
      coupling_monitor(tmp_model, parameter_getter);

   coupling_monitor.run(low_scale, susy_scale, 100, true);
   coupling_monitor.write_to_file(filename);
}

/**
 * Write spectrum (pole masses) to a text file
 *
 * @param filename output file name
 */
template <class T>
void @ModelName@_runner<T>::write_spectrum(const std::string& filename) const
{
   @ModelName@_spectrum_plotter plotter;
   plotter.extract_spectrum<T>(model);
   plotter.write_to_file(filename);
}

} // namespace flexiblesusy

int main(int argc, const char* argv[])
{
   using namespace flexiblesusy;
   using namespace softsusy;
   typedef Two_scale algorithm_type;

   Command_line_options options(argc, argv);
   if (options.must_exit())
      return options.status();

   const std::string slha_input_file(options.get_slha_input_file());
   const std::string slha_output_file(options.get_slha_output_file());
   @ModelName@_slha_io slha_io;
   Program_options program_options;
   QedQcd oneset;
   @ModelName@_input_parameters input;

   if (!slha_input_file.empty()) {
      try {
         slha_io.read_from_file(slha_input_file);
         slha_io.fill(oneset);
         slha_io.fill(input);
         slha_io.fill(program_options);
      } catch (const Error& error) {
         ERROR(error.what());
         return 1;
      }
   }
   oneset.toMz(); // run SM fermion masses to MZ

   @ModelName@_runner<algorithm_type> runner;
   runner.set_precision_goal(program_options.get(Program_options::precision));
   runner.set_max_iterations(program_options.get(Program_options::max_iterations));
   runner.set_calculate_sm_masses(
      program_options.get(Program_options::calculate_sm_masses) >= 1.0);
   runner.set_parameter_output_scale(slha_io.get_parameter_output_scale());
   runner.set_pole_mass_loop_order(
      program_options.get(Program_options::pole_mass_loop_order));
   runner.set_ewsb_loop_order(
      program_options.get(Program_options::ewsb_loop_order));

   runner.run(oneset, input);

   if (slha_output_file.empty()) {
      if (runner.get_problems().have_serious_problem())
         runner.get_problems().print();
      else
         runner.get_model().print(std::cout);
   } else {
      slha_io.set_spinfo(runner.get_problems());
      if (!runner.get_problems().have_serious_problem())
         slha_io.set_spectrum(runner.get_model());
      slha_io.write_to_file(slha_output_file);
   }

   return 0;
}
